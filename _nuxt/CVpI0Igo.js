import{an as F,u as x,L as w,ao as L,ap as V,P as H,aq as U,c as $,ar as A,as as G,S as O,J as I,H as W,r as z,K as j,at as J,au as Q,ak as X,G as T,av as Y}from"./B6z02HQ5.js";const Z={trailing:!0};function k(a,e=25,o={}){if(o={...Z,...o},!Number.isFinite(e))throw new TypeError("Expected `wait` to be a finite number");let i,n,l=[],s,t;const v=(d,y)=>(s=K(a,d,y),s.finally(()=>{if(s=null,o.trailing&&t&&!n){const m=v(d,t);return t=null,m}}),s),b=function(...d){return o.trailing&&(t=d),s||new Promise(y=>{const m=!n&&o.leading;clearTimeout(n),n=setTimeout(()=>{n=null;const u=o.leading?i:v(this,d);t=null;for(const f of l)f(u);l=[]},e),m?(i=v(this,d),y(i)):l.push(y)})},r=d=>{d&&(clearTimeout(d),n=null)};return b.isPending=()=>!!n,b.cancel=()=>{r(n),l=[],t=null},b.flush=()=>{if(r(n),!t||s)return;const d=t;return t=null,v(this,d)},b}async function K(a,e,o){return await a.apply(e,o)}function ra(...a){const e=typeof a[a.length-1]=="string"?a.pop():void 0;aa(a[0],a[1])&&a.unshift(e);let[o,i,n={}]=a,l=!1;const s=w(()=>L(o));if(typeof s.value!="string")throw new TypeError("[nuxt] [useAsyncData] key must be a string.");if(typeof i!="function")throw new TypeError("[nuxt] [useAsyncData] handler must be a function.");const t=x();n.server??=!0,n.default??=ta,n.getCachedData??=N,n.lazy??=!1,n.immediate??=!0,n.deep??=V.deep,n.dedupe??="cancel",n._functionName,t._asyncData[s.value];function v(){const u={cause:"initial",dedupe:n.dedupe};return t._asyncData[s.value]?._init||(u.cachedData=n.getCachedData(s.value,t,{cause:"initial"}),t._asyncData[s.value]=M(t,s.value,i,n,u.cachedData)),()=>t._asyncData[s.value].execute(u)}const b=v(),r=t._asyncData[s.value];r._deps++;const d=n.server!==!1&&t.payload.serverRendered;{let u=function(c){const _=t._asyncData[c];_?._deps&&(_._deps--,_._deps===0&&_?._off())};const f=H();if(f&&d&&n.immediate&&!f.sp&&(f.sp=[]),f&&!f._nuxtOnBeforeMountCbs){f._nuxtOnBeforeMountCbs=[];const c=f._nuxtOnBeforeMountCbs;U(()=>{c.forEach(_=>{_()}),c.splice(0,c.length)}),$(()=>c.splice(0,c.length))}const h=f&&(f._nuxtClientOnly||A(G,!1));d&&t.isHydrating&&(r.error.value||r.data.value!==void 0)?r.status.value=r.error.value?"error":"success":f&&(!h&&t.payload.serverRendered&&t.isHydrating||n.lazy)&&n.immediate?f._nuxtOnBeforeMountCbs.push(b):n.immediate&&r.status.value!=="success"&&b();const D=W(),p=O(s,(c,_)=>{if((c||_)&&c!==_){l=!0;const P=t._asyncData[_]?.data.value!==void 0,B=t._asyncDataPromises[_]!==void 0,S={cause:"initial",dedupe:n.dedupe};if(!t._asyncData[c]?._init){let C;_&&P?C=t._asyncData[_].data.value:(C=n.getCachedData(c,t,{cause:"initial"}),S.cachedData=C),t._asyncData[c]=M(t,c,i,n,C)}t._asyncData[c]._deps++,_&&u(_),(n.immediate||P||B)&&t._asyncData[c].execute(S),Y(()=>{l=!1})}},{flush:"sync"}),g=n.watch?O(n.watch,()=>{l||r._execute({cause:"watch",dedupe:n.dedupe})}):()=>{};D&&I(()=>{p(),g(),u(s.value)})}const y={data:E(()=>t._asyncData[s.value]?.data),pending:E(()=>t._asyncData[s.value]?.pending),status:E(()=>t._asyncData[s.value]?.status),error:E(()=>t._asyncData[s.value]?.error),refresh:(...u)=>t._asyncData[s.value]?._init?t._asyncData[s.value].execute(...u):v()(),execute:(...u)=>y.refresh(...u),clear:()=>{const u=t._asyncData[s.value];if(u?._abortController)try{u._abortController.abort(new DOMException("AsyncData aborted by user.","AbortError"))}finally{u._abortController=void 0}q(t,s.value)}},m=Promise.resolve(t._asyncDataPromises[s.value]).then(()=>y);return Object.assign(m,y),m}function E(a){return w({get(){return a()?.value},set(e){const o=a();o&&(o.value=e)}})}function aa(a,e){return!(typeof a=="string"||typeof a=="object"&&a!==null||typeof a=="function"&&typeof e=="function")}async function oa(a){await new Promise(o=>F(o)),await x().hooks.callHookParallel("app:data:refresh",void 0)}function q(a,e){e in a.payload.data&&(a.payload.data[e]=void 0),e in a.payload._errors&&(a.payload._errors[e]=void 0),a._asyncData[e]&&(a._asyncData[e].data.value=T(a._asyncData[e]._default()),a._asyncData[e].error.value=void 0,a._asyncData[e].status.value="idle"),e in a._asyncDataPromises&&(a._asyncDataPromises[e]=void 0)}function ea(a,e){const o={};for(const i of e)o[i]=a[i];return o}function M(a,e,o,i,n){a.payload._errors[e]??=void 0;const l=i.getCachedData!==N,s=o,t=i.deep?z:j,v=n!==void 0,b=a.hook("app:data:refresh",async d=>{(!d||d.includes(e))&&await r.execute({cause:"refresh:hook"})}),r={data:t(v?n:i.default()),pending:w(()=>r.status.value==="pending"),error:J(a.payload._errors,e),status:j("idle"),execute:(...d)=>{const[y,m=void 0]=d,u=y&&m===void 0&&typeof y=="object"?y:{};if(a._asyncDataPromises[e]&&(u.dedupe??i.dedupe)==="defer")return a._asyncDataPromises[e];{const h="cachedData"in u?u.cachedData:i.getCachedData(e,a,{cause:u.cause??"refresh:manual"});if(h!==void 0)return a.payload.data[e]=r.data.value=h,r.error.value=void 0,r.status.value="success",Promise.resolve(h)}r._abortController&&r._abortController.abort(new DOMException("AsyncData request cancelled by deduplication","AbortError")),r._abortController=new AbortController,r.status.value="pending";const f=new Promise((h,D)=>{try{const p=u.timeout??i.timeout,g=na([r._abortController?.signal,u?.signal],p);if(g.aborted){const c=g.reason;D(c instanceof Error?c:new DOMException(String(c??"Aborted"),"AbortError"));return}return g.addEventListener("abort",()=>{const c=g.reason;D(c instanceof Error?c:new DOMException(String(c??"Aborted"),"AbortError"))},{once:!0}),Promise.resolve(s(a,{signal:g})).then(h,D)}catch(p){D(p)}}).then(async h=>{let D=h;i.transform&&(D=await i.transform(h)),i.pick&&(D=ea(D,i.pick)),a.payload.data[e]=D,r.data.value=D,r.error.value=void 0,r.status.value="success"}).catch(h=>{if(!(a._asyncDataPromises[e]&&a._asyncDataPromises[e]!==f)&&!r._abortController?.signal.aborted){if(typeof DOMException<"u"&&h instanceof DOMException&&h.name==="AbortError"){r.status.value="idle";return}r.error.value=X(h),r.data.value=T(i.default()),r.status.value="error"}}).finally(()=>{delete a._asyncDataPromises[e]});return a._asyncDataPromises[e]=f,a._asyncDataPromises[e]},_execute:k((...d)=>r.execute(...d),0,{leading:!0}),_default:i.default,_deps:0,_init:!0,_hash:void 0,_off:()=>{b(),a._asyncData[e]?._init&&(a._asyncData[e]._init=!1),l||Q(()=>{a._asyncData[e]?._init||(q(a,e),r.execute=()=>Promise.resolve())})}};return r}const ta=()=>{},N=(a,e,o)=>{if(e.isHydrating)return e.payload.data[a];if(o.cause!=="refresh:manual"&&o.cause!=="refresh:hook")return e.static.data[a]};function na(a,e){const o=a.filter(l=>!!l);if(typeof e=="number"&&e>=0){const l=AbortSignal.timeout?.(e);l&&o.push(l)}if(AbortSignal.any)return AbortSignal.any(o);const i=new AbortController;for(const l of o)if(l.aborted){const s=l.reason??new DOMException("Aborted","AbortError");try{i.abort(s)}catch{i.abort()}return i.signal}const n=()=>{const s=o.find(t=>t.aborted)?.reason??new DOMException("Aborted","AbortError");try{i.abort(s)}catch{i.abort()}};for(const l of o)l.addEventListener?.("abort",n,{once:!0});return i.signal}const R={content:"v3.5.0--KLJxO-7EtdqTSlSPhdke7AnIwpVEfBsGdSn0UVbT3Kk"},ia={content:"_content_content",info:"_content_info"},ca={content:{type:"page",fields:{id:"string",title:"string",body:"json",cta:"json",description:"string",extension:"string",features:"json",hero:"json",meta:"json",navigation:"json",path:"string",pricing:"json",section:"json",seo:"json",stem:"string",steps:"json",testimonials:"json"}},info:{type:"data",fields:{}}};async function ua(a,e){return await $fetch(`/__nuxt_content/${e}/sql_dump.txt`,{context:{},responseType:"text",headers:{"content-type":"text/plain"},query:{v:R[String(e)],t:void 0}})}async function la(a,e,o){return await $fetch(`/__nuxt_content/${e}/query`,{context:a?{cloudflare:a.context.cloudflare}:{},headers:{"content-type":"application/json",...a?.node?.req?.headers?.cookie?{cookie:a.node.req.headers.cookie}:{}},query:{v:R[String(e)],t:void 0},method:"POST",body:{sql:o}})}export{R as a,ua as b,ca as c,la as f,oa as r,ia as t,ra as u};
